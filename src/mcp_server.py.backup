
"""
MCP Server for Agent-Driven Python Debugging and Testing

IMPORTANT: This MCP server is designed to be automatically started by MCP clients
(VS Code, Claude Desktop, etc.). You do NOT need to run this manually from the
command line. The client will automatically start this server when needed.

Configuration examples:
- VS Code: Add to settings.json under "mcp.servers"
- Claude Desktop: Add to claude_desktop_config.json under "mcpServers"

The server provides tools for:
- Running pytest with JSON reports
- Debug Adapter Protocol (DAP) debugging
- Setting breakpoints and inspecting variables
"""

import argparse
import asyncio
import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from mcp.server.fastmcp import FastMCP
from dap_stdio_client import StdioDAPClient
from debug_utils import log_debug

mcp = FastMCP("agent-debug-tools")

def _get_python_executable() -> Path:
    """Get the correct Python executable, preferring virtual environment if available."""
    # First check if we're already in a virtual environment via VIRTUAL_ENV
    if 'VIRTUAL_ENV' in os.environ:
        venv_python = Path(os.environ['VIRTUAL_ENV']) / "bin" / "python"
        if venv_python.exists():
            log_debug(f"_get_python_executable: using VIRTUAL_ENV {venv_python}")
            return venv_python
    
    # Check if we're in a virtual environment relative to current working directory
    cwd = Path.cwd()
    venv_path = cwd / ".venv" / "bin" / "python"
    if venv_path.exists():
        log_debug(f"_get_python_executable: using cwd .venv {venv_path}")
        return venv_path
    
    # Check for other common venv locations
    for venv_name in [".venv", "venv", "env"]:
        venv_python = cwd / venv_name / "bin" / "python"
        if venv_python.exists():
            log_debug(f"_get_python_executable: using cwd venv {venv_python}")
            return venv_python
    
    # Check parent directories for virtual environments
    for parent in cwd.parents:
        for venv_name in [".venv", "venv", "env"]:
            venv_python = parent / venv_name / "bin" / "python"
            if venv_python.exists():
                log_debug(f"_get_python_executable: using ancestor venv {venv_python}")
                return venv_python

    # Fall back to sys.executable
    fallback = Path(sys.executable)
    log_debug(f"_get_python_executable: falling back to sys.executable {fallback}")
    return fallback

@mcp.tool()
def run_tests_json(pytest_args: Optional[List[str]] = None) -> Dict[str, Any]:
    """Run pytest and return parsed JSON report.
    Args:
      pytest_args: extra pytest args (e.g., ["-k", "unit"])
    """
    report = Path(".pytest-report.json")
    python_exec = _get_python_executable()
    if not python_exec.exists():
        return {"error": "Python executable not found", "executable": str(python_exec)}

    cmd = [str(python_exec), "-m", "pytest", "--json-report", f"--json-report-file={report}"]
    if pytest_args:
        cmd += pytest_args
    # keep output quiet but still run failures
    cmd += ["-q", "--maxfail=1"]
    
    # Add debugging information
    # Change to the directory containing the MCP server
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.dirname(script_dir)
    
    # Change to project root directory
    original_cwd = os.getcwd()
    os.chdir(project_root)
    
    debug_info = {
        "python_executable": str(python_exec),
        "current_working_directory": os.getcwd(),
        "original_working_directory": original_cwd,
        "project_root": project_root,
        "virtual_env": os.environ.get("VIRTUAL_ENV"),
    }
    log_debug(f"run_tests_json: executing command={' '.join(cmd)} info={debug_info}")
    
    # Do not raise on fail; we want to return the JSON either way
    # Redirect all subprocess output to avoid interfering with MCP JSON protocol
    try:
        result = subprocess.run(
            cmd,
            check=False,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        debug_info["return_code"] = result.returncode
        log_debug(f"run_tests_json: returncode={result.returncode}")
    except FileNotFoundError as e:
        log_debug(f"run_tests_json: FileNotFoundError {e}")
        # Restore original working directory
        os.chdir(original_cwd)
        return {
            "error": "pytest executable not found",
            "note": "Ensure pytest is installed in the same environment as the MCP server.",
            "debug": debug_info,
            "exception": str(e)
        }
    if report.exists():
        data = json.loads(report.read_text())
        data["debug"] = debug_info
        log_debug("run_tests_json: report file found and parsed")
        # Restore original working directory
        os.chdir(original_cwd)
        return data
    log_debug("run_tests_json: report file missing after execution")
    # Restore original working directory
    os.chdir(original_cwd)
    return {
        "error": "Report not found",
        "note": "pytest-json-report plugin may be missing or tests did not run.",
        "debug": debug_info,
    }

@mcp.tool()
def run_tests_focus(keyword: str) -> Dict[str, Any]:
    """Run a focused subset: pytest -k <keyword> with JSON report."""
    return run_tests_json(["-k", keyword])

# --- DAP Tools ---
# We keep a single stdio DAP connection per process for simplicity
_dap_client: Optional[StdioDAPClient] = None

async def _ensure_stdio_client(restart: bool = False) -> StdioDAPClient:
    """Create (or recreate) the global stdio DAP client."""
    global _dap_client
    if _dap_client and restart:
        await _dap_client.close()
        _dap_client = None
    if _dap_client is None:
        _dap_client = StdioDAPClient()
        await _dap_client.start()
    return _dap_client

async def _require_client() -> StdioDAPClient:
    client = await _ensure_stdio_client(restart=False)
    if client is None:
        raise RuntimeError("DAP client is not initialized")
    return client

async def _resilient_set_breakpoints(
    client: StdioDAPClient,
    source_path: str,
    lines: List[int],
    wait_timeout: float = 5.0,
) -> Tuple[Dict[str, Any], Optional[Dict[str, Any]]]:
    """Set breakpoints and retry once if adapter was not yet initialized."""
    try:
        primary = await client.setBreakpoints(source_path, lines)
    except RuntimeError as err:
        log_debug(f"_resilient_set_breakpoints: adapter unavailable: {err}")
        return {"success": False, "message": str(err)}, None
    if primary.get("success", True):
        return primary, None
    if primary.get("message") != "Server is not available":
        return primary, None
    if wait_timeout is not None and wait_timeout <= 0:
        if not client.initialized_received():
            return primary, None
    else:
        try:
            await client.wait_for_initialized(timeout=wait_timeout)
        except asyncio.TimeoutError:
            return primary, None
    try:
        retry = await client.setBreakpoints(source_path, lines)
    except RuntimeError as err:
        log_debug(f"_resilient_set_breakpoints retry: adapter unavailable: {err}")
        return {"success": False, "message": str(err)}, primary
    return retry, primary

async def _resilient_set_exception_breakpoints(
    client: StdioDAPClient,
    filters: Optional[List[str]] = None,
    wait_timeout: float = 5.0,
) -> Tuple[Dict[str, Any], Optional[Dict[str, Any]]]:
    """Send setExceptionBreakpoints with an optional retry."""
    try:
        primary = await client.setExceptionBreakpoints(filters or [])
    except RuntimeError as err:
        log_debug(f"_resilient_set_exception_breakpoints: adapter unavailable: {err}")
        return {"success": False, "message": str(err)}, None
    if primary.get("success", True):
        return primary, None
    if primary.get("message") != "Server is not available":
        return primary, None
    if wait_timeout is not None and wait_timeout <= 0:
        if not client.initialized_received():
            return primary, None
    else:
        try:
            await client.wait_for_initialized(timeout=wait_timeout)
        except asyncio.TimeoutError:
            return primary, None
    try:
        retry = await client.setExceptionBreakpoints(filters or [])
    except RuntimeError as err:
        log_debug(f"_resilient_set_exception_breakpoints retry: adapter unavailable: {err}")
        return {"success": False, "message": str(err)}, primary
    return retry, primary

@mcp.tool()
async def dap_launch(
    program: str,
    cwd: Optional[str] = None,
    breakpoints: Optional[List[int]] = None,
    console: str = "internalConsole",
    wait_for_breakpoint: bool = True,
    breakpoint_timeout: float = 5.0,
) -> Dict[str, Any]:
    """
    Launch a program under debugpy.adapter via stdio, optionally waiting for a breakpoint hit.
    """
    import logging
    logging.basicConfig(level=logging.DEBUG)
    logger = logging.getLogger(__name__)
    
    logger.debug(f"DAP Launch starting: program={program}, cwd={cwd}, breakpoints={breakpoints}")
    result: Dict[str, Any] = {"debug_log": []}
    
    try:
        client = await _ensure_stdio_client(restart=True)
        logger.debug("DAP client obtained")
        
        program_path = Path(program).resolve()
        launch_cwd = Path(cwd).resolve() if cwd else program_path.parent
        logger.debug(f"Resolved paths: program={program_path}, cwd={launch_cwd}")

        result["debug_log"].append("Starting initialize")
        init_resp = await client.initialize()
        result["initialize"] = init_resp
        logger.debug(f"Initialize response: {init_resp}")

        try:
            result["debug_log"].append("Waiting for initialized")
            await client.wait_for_initialized(timeout=1.0)
            result["initializedEarly"] = True
            logger.debug("Initialized early")
        except asyncio.TimeoutError:
            result["initializedEarly"] = False
            logger.debug("Initialize timeout - will wait later")

        bp_retry: Optional[Dict[str, Any]] = None
        bp_resp: Optional[Dict[str, Any]] = None
        if breakpoints:
            result["debug_log"].append(f"Setting breakpoints: {breakpoints}")
            logger.debug(f"Setting breakpoints: {breakpoints}")
            bp_resp, bp_retry = await _resilient_set_breakpoints(
                client, str(program_path), breakpoints, wait_timeout=5.0
            )
            result["setBreakpoints"] = bp_resp
            logger.debug(f"Breakpoints response: {bp_resp}")
            if bp_retry:
                result["setBreakpointsInitial"] = bp_retry

        exc_resp, exc_retry = await _resilient_set_exception_breakpoints(client, [], wait_timeout=5.0)
        result["setExceptionBreakpoints"] = exc_resp
        logger.debug(f"Exception breakpoints response: {exc_resp}")
        if exc_retry:
            result["setExceptionBreakpointsInitial"] = exc_retry

        result["debug_log"].append("Creating launch task")
        launch_task = asyncio.create_task(
            client.launch(
                program=str(program_path),
                cwd=str(launch_cwd),
                console=console,
            )
        )
        logger.debug("Launch task created")

        result["debug_log"].append("Sending configurationDone")
        cfg_resp = await client.configurationDone()
        result["configurationDone"] = cfg_resp
        logger.debug(f"ConfigurationDone response: {cfg_resp}")

        if not result.get("initializedEarly", False):
            try:
                result["debug_log"].append("Waiting for initialized (later)")
                await client.wait_for_initialized(timeout=5.0)
                result["initializedLater"] = True
                logger.debug("Initialized later")
            except asyncio.TimeoutError:
                result["initializedLater"] = False
                logger.debug("Initialize timeout (later)")

            if breakpoints and (not bp_resp or not bp_resp.get("success", True)):
                result["debug_log"].append("Retrying breakpoints after init")
                bp_resp_retry, _ = await _resilient_set_breakpoints(
                    client, str(program_path), breakpoints, wait_timeout=0.0
                )
                result["setBreakpointsRetryAfterInit"] = bp_resp_retry
                logger.debug(f"Breakpoints retry response: {bp_resp_retry}")

            if not exc_resp.get("success", True):
                result["debug_log"].append("Retrying exception breakpoints after init")
                exc_resp_retry, _ = await _resilient_set_exception_breakpoints(
                    client, [], wait_timeout=0.0
                )
                result["setExceptionBreakpointsRetryAfterInit"] = exc_resp_retry

        result["debug_log"].append("Waiting for launch task")
        launch_resp = await launch_task
        result["launch"] = launch_resp
        logger.debug(f"Launch response: {launch_resp}")

        if wait_for_breakpoint:
            if breakpoints:
                try:
                    result["debug_log"].append(f"Waiting for stopped event (timeout={breakpoint_timeout})")
                    logger.debug(f"Waiting for stopped event with timeout {breakpoint_timeout}")
                    stopped = await client.wait_for_event("stopped", timeout=breakpoint_timeout)
                    result["stoppedEvent"] = stopped
                    logger.debug(f"Stopped event received: {stopped}")
                except asyncio.TimeoutError:
                    result["stoppedEvent"] = {"timeout": breakpoint_timeout}
                    logger.debug(f"Timeout waiting for stopped event after {breakpoint_timeout}s")
            else:
                result["stoppedEvent"] = {"skipped": "no breakpoints configured"}

        result["debug_log"].append("DAP launch completed successfully")
        logger.debug("DAP launch completed successfully")
        return result
        
    except Exception as e:
        logger.error(f"DAP launch failed: {e}", exc_info=True)
        error_message = str(e)
        debug_log = result.get("debug_log", []) + [f"Exception: {e}"]
        response: Dict[str, Any] = {"error": error_message, "debug_log": debug_log}
        if "Operation not permitted" in error_message:
            hint = (
                "debugpy.adapter could not create its local socket listeners "
                "(PermissionError: Operation not permitted). This usually means the "
                "current environment blocks network socket creation. Allow local "
                "loopback networking or run in an environment that permits it."
            )
            debug_log.append("Adapter stderr reported PermissionError (socket creation blocked).")
            response["hint"] = hint
        return response

@mcp.tool()
async def dap_set_breakpoints(source_path: str, lines: List[int]) -> Dict[str, Any]:
    """Set breakpoints by absolute source path and line numbers."""
    client = await _require_client()
    source = str(Path(source_path).resolve())
    resp, initial = await _resilient_set_breakpoints(client, source, lines, wait_timeout=5.0)
    result = {"response": resp}
    if initial and initial is not resp:
        result["initial"] = initial
    return result

@mcp.tool()
async def dap_continue(thread_id: Optional[int] = None) -> Dict[str, Any]:
    """Continue execution on the given thread; if not provided, uses first thread."""
    client = await _require_client()
    th = await client.threads()
    threads = th.get("body", {}).get("threads", [])
    if not threads:
        return {"error": "No threads"}
    tid = thread_id or threads[0]["id"]
    resp = await client.continue_(tid)
    return {"threads": th, "continue": resp}

@mcp.tool()
async def dap_locals() -> Dict[str, Any]:
    """Return locals from the top stack frame of the first thread."""
    client = await _require_client()
    th = await client.threads()
    threads = th.get("body", {}).get("threads", [])
    if not threads:
        return {"error": "No threads"}
    tid = threads[0]["id"]
    st = await client.stackTrace(tid)
    frames = st.get("body", {}).get("stackFrames", [])
    if not frames:
        return {"error": "No frames"}
    top = frames[0]
    scopes = await client.scopes(top["id"])
    locals_ref = None
    for sc in scopes.get("body", {}).get("scopes", []):
        if sc.get("name", "").lower().startswith("locals"):
            locals_ref = sc["variablesReference"]
            break
    if not locals_ref:
        return {"error": "Locals scope not found"}
    vars_payload = await client.variables(locals_ref)
    return {
        "threads": th,
        "stackTrace": st,
        "scopes": scopes,
        "variables": vars_payload,
    }

@mcp.tool()
async def dap_wait_for_event(name: str, timeout: float = 5.0) -> Dict[str, Any]:
    """Wait for a specific DAP event (e.g., 'stopped')."""
    client = await _require_client()
    try:
        event = await client.wait_for_event(name, timeout=timeout)
        return {"event": event}
    except asyncio.TimeoutError:
        return {"timeout": timeout, "event": name}

@mcp.tool()
async def dap_shutdown() -> Dict[str, Any]:
    """Terminate the current DAP adapter session."""
    global _dap_client
    if _dap_client:
        await _dap_client.close()
        _dap_client = None
        return {"status": "stopped"}
    return {"status": "no-session"}

def print_help():
    """Print help information about the MCP server and its tools."""
    help_text = """
MCP Server for Agent-Driven Python Debugging and Testing

IMPORTANT: This MCP server is designed to be automatically started by MCP clients
(VS Code, Claude Desktop, etc.). You do NOT need to run this manually from the
command line. The client will automatically start this server when needed.

Configuration:
==============
Use the provided configuration helper script to set up MCP clients:

    python scripts/configure_mcp_clients.py

This script will:
• Detect existing VS Code/Claude MCP configurations
• Interactively add/update/remove MCP server entries
• Generate configuration snippets for Claude Desktop
• Handle path resolution and environment setup automatically

Manual Configuration (if needed):
=================================
VS Code - Add to settings.json under "mcp.servers":
{
  "mcp.servers.agentDebug": {
    "command": "/path/to/your/project/.venv/bin/python",
    "args": ["src/mcp_server.py"],
    "cwd": "/path/to/your/project"
  }
}

Claude Desktop - Add to claude_desktop_config.json under "mcpServers":
{
  "mcpServers": {
    "agentDebug": {
      "command": "/path/to/your/project/.venv/bin/python", 
      "args": ["src/mcp_server.py"],
      "cwd": "/path/to/your/project"
    }
  }
}

Available MCP Tools:
==================

Testing Tools:
--------------
• run_tests_json(pytest_args: Optional[List[str]]) 
  Run pytest with JSON report output
  
• run_tests_focus(keyword: str)
  Run focused subset of tests using pytest -k <keyword>

Debug Adapter Protocol (DAP) Tools:
-----------------------------------
• dap_launch(program: str, cwd: Optional[str], breakpoints: Optional[List[int]], 
             console: str, wait_for_breakpoint: bool, breakpoint_timeout: float)
  Launch a program under debugpy.adapter with optional breakpoints
  
• dap_set_breakpoints(source_path: str, lines: List[int])
  Set breakpoints by absolute source path and line numbers
  
• dap_continue(thread_id: Optional[int])
  Continue execution on the given thread
  
• dap_locals()
  Return locals from the top stack frame of the first thread
  
• dap_wait_for_event(name: str, timeout: float)
  Wait for a specific DAP event (e.g., 'stopped')
  
• dap_shutdown()
  Terminate the current DAP adapter session

Usage Workflow:
===============
1. Run configuration helper: python scripts/configure_mcp_clients.py
2. Use the tools through your MCP client interface (VS Code AI Chat, Claude Desktop)
3. The server automatically manages debugpy.adapter processes

Example Debug Session:
======================
• dap_launch({"program": "examples/math_bug/calculator.py", "breakpoints": [43]})
• dap_locals() - inspect variables at breakpoint
• dap_continue() - resume execution
• dap_shutdown() - clean up when done

Example Test Session:
====================
• run_tests_json(["-k", "math_bug"]) - run specific tests
• run_tests_focus("subtract") - focus on tests matching keyword

For more information, see README.md
"""
    print(help_text)

if __name__ == "__main__":
    # Check for help request before creating ArgumentParser
    if "--help" in sys.argv or "-h" in sys.argv:
        print_help()
        sys.exit(0)
    
    # If no --help, start the MCP server normally
    mcp.run()
